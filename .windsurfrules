# Windsurf AI Rules (.windsurfrules)
# Last Updated: 2025-04-18

# --- Core Principles ---
# - Be concise and focus only on the user's specific request.
# - Prefer standard libraries over adding new dependencies unless explicitly asked.
# - Adhere strictly to the language/framework conventions outlined below.
# - Validate inputs and handle errors robustly, especially in Rust/Tauri backend code.
# - Maintain code quality (readability, naming conventions, small functions).

## General Code Generation Guidelines

* Generate code *only* to address the specific task requested. Avoid unrelated changes or additions.
* Keep generated code snippets concise and minimal. Focus on the core logic needed.
* Avoid generating excessive boilerplate code (e.g., redundant comments, complex setup) unless strictly necessary.
* Do *not* introduce new external libraries or dependencies unless explicitly requested by the user.
* Strongly prefer using built-in functions and modules from the language's standard library first.
* When modifying existing code, keep changes localized and directly related to the prompt. Avoid refactoring unrelated code sections unless asked.
* Do not make broad assumptions about the project structure or existing utilities.

## Python Specific Guidelines

* Prefer specific imports (`from module import member`) over whole module imports (`import module`) unless multiple members are needed. Remove unused imports.
* Favor modern standard library modules (e.g., `pathlib` over `os.path`, `datetime`). Leverage standard collections (`collections`, `itertools`) before suggesting external libraries.
* Use list/dict/set comprehensions and generator expressions for conciseness where readable and appropriate.
* Use f-strings for string formatting (assume Python 3.6+).
* Employ context managers (`with` statement) for resource management (`with open(...)`).
* Catch specific exception types rather than bare `except:` or `except Exception:`.
* Follow PEP 8 naming conventions (`snake_case`, `PascalCase`).
* Add basic, concise type hints (PEP 484) to function signatures unless requested otherwise.
* Generate concise single-line or minimal docstrings for new functions/classes unless more detail is requested.

## Rust Specific Guidelines

* Strongly prefer using the Rust standard library (`std`, `core`, `alloc`).
* Do *not* add new external crate dependencies (`Cargo.toml`) unless explicitly requested or clearly necessary.
* Use `Result<T, E>` for recoverable errors. Utilize the `?` operator for concise error propagation. Implement `std::error::Error` for custom error types if needed.
* Avoid `panic!` for expected or recoverable errors.
* Strictly avoid indiscriminate use of `.unwrap()` or `.expect()`. Handle `Option` and `Result` explicitly (`match`, `if let`, `map`, `ok_or_else`, etc.). Use `.expect("reason")` only when a panic is truly justified by invariants.
* Prefer borrowing (`&`, `&mut`) over cloning (`.clone()`) where possible. Respect ownership rules.
* Leverage iterators and their adapter methods (`map`, `filter`, `fold`, `collect`, etc.) for concise data processing.
* Implement relevant standard library traits (`Debug`, `Display`, `Default`, `Clone`, `Error`, `Send`, `Sync`, etc.) where applicable.
* Use standard macros (`println!`, `format!`, `vec!`, `dbg!`) effectively.
* Use `Path`/`PathBuf` for filesystem paths. Distinguish `&str` vs `String`.
* Follow standard `rustfmt` formatting and Rust naming conventions (`snake_case`, `PascalCase`).
* Keep functions focused and small. Validate inputs received via IPC.

## Svelte 5 Specific Guidelines (Runes)

* **Prioritize Runes:** Use `$state`, `$derived`, `$effect` exclusively for reactivity in new components.
* Avoid Svelte 4 syntax (`$:`, `onMount` for reactive effects, reactive `let`).
* Define component props using `$props()`. Use `$bindable()` for two-way bindable props. Avoid `export let`.
* Use `bind:property` for two-way data binding.
* Define event handlers as functions in `<script>`. Keep inline handlers simple.
* Use `{#each items as item (item.id)}` (with keys) and `{#if ...}` for template logic. Keep template logic simple; move complexity to `$derived` or helper functions.
* Favor creating smaller, reusable components.
* Use Svelte stores (`svelte/store`) *only* for cross-component state when props/runes become impractical. Prefer runes for local state.

## SvelteKit Specific Guidelines (adapter-static & Tauri Context)

* Assume `adapter-static` is used for build output targeting Tauri (no dynamic Node.js server post-deployment).
* Use `export const prerender = true` for static pages or `export const ssr = false` for client-rendered (SPA-like) pages.
* **Prioritize `+page.js` / `+layout.js`** for data loading (runs at build/prerender time and client-side). Use the provided `Workspace`.
* **Limit Server Modules (`.server.js`):** Use *only* for build-time data fetching supporting prerendering. Avoid for dynamic post-deployment logic.
* **Static API Routes (`+server.js`):** Only useful during development or prerendering; they *do not run* in the deployed Tauri app.
* **Use Tauri IPC for Backend:** For dynamic backend interactions, use Tauri's `invoke` mechanism from `@tauri-apps/api/core`. Do *not* implement this logic in SvelteKit server modules.
* **Form Handling:** Handle forms client-side and use Tauri `invoke` to interact with the Rust backend. Avoid SvelteKit Form Actions relying on dynamic server processing.
* Use only public environment variables (`$env/static/public`).
* Use standard `<a href>` or `goto()` for navigation. Reference static assets appropriately.

## Tauri 2.0 Specific Guidelines

* **Prioritize IPC:** Use `invoke` (JS->Rust) and events (Rust->JS or decoupled) via `@tauri-apps/api/core` and `@tauri-apps/api/event`. Consider `tauri::ipc::Channel` for streaming.
* **APIs are Plugins:** Most native features require official plugins (e.g., `tauri-plugin-fs`). Import JS functions from `@tauri-apps/plugin-*`.
* **Initialize Plugins:** Ensure plugins are added to `Cargo.toml`/`package.json` and initialized in Rust (`tauri::Builder::plugin(...)`).
* **Configure Permissions:** Explicitly enable *all* required capabilities/permissions/scopes for APIs and commands in `Tauri.toml` using the principle of least privilege.
* **Rust Backend (`src-tauri`):**
    * Define commands with `#[tauri::command]`, returning `Result<T, E>` (where `E: Serialize`). Use `async fn` for I/O.
    * Use `tauri::Builder` in `main.rs` for setup, plugin initialization, and state management (`app.manage(...)`).
    * Validate all inputs received from the frontend via `invoke` in Rust.
* **JS Frontend:**
    * Handle `invoke` Promises using `async/await` and `try...catch`.
    * Use `WebviewWindow`/`appWindow` from `@tauri-apps/api/core` to manage windows.
    * Clean up event listeners (`unlisten()`).
* Keep Tauri dependencies updated for security.
