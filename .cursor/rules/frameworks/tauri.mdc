---
description: Rules for Tauri 2.0 application code, ensuring proper API usage, permissions, and compatibility
globs:
alwaysApply: false
---
# Tauri 2.0 Specific Heuristics

# Core Interaction (IPC - Invoke & Events)
- **Prioritize IPC:** Use Tauri's IPC as the primary communication channel between the SvelteKit frontend and the Rust backend.
- **Use `invoke` for Commands:**
    - Call Rust functions exposed via `#[tauri::command]` using `invoke('command_name', { args... })` from `@tauri-apps/api/core`.
    - Design commands for specific actions or data requests requiring Rust/native capabilities.
    - Handle the returned `Promise` in JavaScript/TypeScript using `async/await` and `try...catch`, as Rust commands should return `Result<T, E>` (where `E: Serialize`) and errors cause the promise to reject.
- **Use Events for Backend-to-Frontend:**
    - Employ Tauri events (`emit` from Rust, `listen` from `@tauri-apps/api/event` in JS) for backend-initiated updates, progress reporting, or decoupled communication.
    - Use `emit_to("window-label", ...)` in Rust for window-specific events.
    - Remember to call the `unlisten()` function returned by `listen` when the listener is no longer needed (e.g., in Svelte's `onDestroy` or `$effect` cleanup) to prevent memory leaks.
- **Consider Channels for Streaming:** For ordered, potentially high-throughput data streams from Rust to JS (e.g., logs, file downloads), consider using `tauri::ipc::Channel`.

# API Usage (Plugins First)
- **APIs are Plugins:** Understand that most native functionalities (Filesystem, HTTP, Dialogs, Shell, Notifications, Clipboard, OS info, etc.) in Tauri 2.0 are provided via official plugins (e.g., `tauri-plugin-fs`, `tauri-plugin-http`).
- **Use Core API:** Import core functionalities like `invoke`, `appWindow`, `WebviewWindow` directly from `@tauri-apps/api/core`.
- **Use Plugin APIs:** Import plugin-specific functions from their respective JS packages (e.g., `import { readTextFile } from '@tauri-apps/plugin-fs';`).
- **Plugin Initialization:** Ensure required plugins are:
    1. Added as dependencies in `Cargo.toml` (`src-tauri`).
    2. Added as dependencies in `package.json` (frontend).
    3. Initialized in `src-tauri/src/main.rs` using `tauri::Builder::default().plugin(tauri_plugin_xxx::init())`. (The `tauri add <plugin>` CLI command often handles this).

# Permissions & Capabilities (Security)
- **Configure Permissions:** Define *all* required permissions explicitly in `Tauri.toml` (preferred) or `tauri.conf.json`. Use the principle of least privilege â€“ only enable what is necessary.
- **Reference Permissions via Capabilities:** Grant configured permissions to windows/webviews by referencing their identifiers within capabilities in the configuration file.
- **Use Scopes:** Define specific scopes (e.g., file paths like `$HOME/my_app/*`) within permissions when applicable (e.g., for `fs` plugin) to restrict access further.
- **Check Plugin Docs:** Consult the documentation for each plugin to understand its available commands and the corresponding permission identifiers needed (e.g., `plugin:fs:allow-read-text-file`, `plugin:fs:scope-home-recursive`). Use default sets like `core:default` or `plugin:fs:default` for convenience if appropriate, but understand what they grant.
- **Frontend Guarding:** Only attempt to use APIs/commands in the frontend that have been explicitly permitted in the configuration.

# Rust Backend (`src-tauri`)
- **Command Definition:** Define backend functions exposed to JS using `#[tauri::command]`. Prefer `async fn` for I/O-bound tasks. Return `Result<T, E>` where `E` is a serializable error type (consider `thiserror`).
- **Application Setup:** Use `tauri::Builder` in `main.rs` to configure the application, initialize plugins, register commands, set up initial windows, manage state (`app.manage(...)`), and run setup logic (`.setup(|app| {...})`).
- **State Management:** Use Tauri's managed state (`app.manage(MyState::new());` in setup, `state: tauri::State<MyState>` as a command argument) for sharing state within the Rust backend.
- **Access App/Window Handles:** Use `AppHandle` or `Window` (obtained via `app.get_webview_window(...)` or command function arguments like `window: tauri::Window`) to interact with the Tauri application at runtime (e.g., emit events, access managed state, create windows).

# General Best Practices
- **Error Handling:** Implement robust error handling on both Rust (`Result`, specific error types) and JS (`try...catch` for `invoke`) sides. Provide meaningful error feedback to the user.
- **Asynchronous Operations:** Use `async/await` consistently for Tauri API calls in JS and for I/O operations or command handlers in Rust.
- **Dependency Updates:** Keep Tauri crates (`tauri`, `tauri-build`, plugins) and NPM packages (`@tauri-apps/api`, `@tauri-apps/plugin-*`) up-to-date for security patches and features.
- **Input Validation:** Always validate and sanitize any data received from the frontend via `invoke` arguments within the Rust backend before using it, especially for file paths, shell commands, or database queries.
