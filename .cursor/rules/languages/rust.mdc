---
description:
globs: *.rs
alwaysApply: false
---
# Rust Specific Heuristics

# Dependencies & Standard Library
- Strongly prefer using items from the Rust standard library (`std`, `core`, `alloc`) over external crates whenever possible (e.g., use `std::fs`, `std::io`, `std::collections`, `std::sync`, `std::error::Error`, `std::path::{Path, PathBuf}`).
- Do *not* add new external crate dependencies to `Cargo.toml` unless explicitly requested by the user or if the required functionality is clearly complex and absent from `std`.

# Error Handling & Safety
- Use `Result<T, E>` for functions that can fail recoverably, using crates like `anyhow` if appropriate and already present or requested.
- Avoid `panic!` for expected error conditions.
- Implement the `std::error::Error` trait for custom error types, possibly using crates like `thiserror` if appropriate *and already present or requested*.
- Utilize the `?` operator liberally for propagating errors within functions returning `Result`.
- Strictly avoid `.unwrap()` or `.expect()` on `Option` and `Result` types in most cases. Prefer explicit handling using `match`, `if let`, `let else`, `map`, `ok_or`, `ok_or_else`, `unwrap_or`, `unwrap_or_default`, etc. Use `.expect("clear reason why this cannot fail")` only when the condition is *absolutely guaranteed* by program logic/invariants.

# Ownership, Borrowing & Lifetimes
- Write code that clearly adheres to Rust's ownership and borrowing rules.
- Prefer immutable borrows (`&T`) by default. Use mutable borrows (`&mut T`) only when mutation is necessary.
- Avoid unnecessary cloning (`.clone()`). Pass data by reference (`&` or `&mut`) when ownership transfer is not required.
- Let the compiler infer lifetimes where possible. Only specify explicit lifetimes when disambiguation is necessary.

# Idiomatic Rust & Conciseness
- Leverage iterators and their adapter methods (`.map()`, `.filter()`, `.fold()`, `.collect()`, `.find()`, etc.) for data processing instead of manual `for` or `while` loops when it improves conciseness and clarity.
- Implement common standard library traits (`Debug`, `Display`, `Clone`, `Copy` (if applicable), `Default`, `From`, `Into`, `PartialEq`, `Eq`, `Ord`, `PartialOrd`, `Hash`, `Send`, `Sync`) where they make sense for custom types.
- Use standard library macros (`println!`, `eprintln!`, `format!`, `vec!`, `dbg!`) appropriately.
- Use `Path`/`PathBuf` for filesystem paths instead of `String` or `&str`.
- Allow type inference (`let x = ...;`) where the type is clear from the context, avoiding redundant annotations.

# Code Quality & Structure
- Generate code that adheres to standard `rustfmt` formatting.
- Follow Rust naming conventions (`snake_case` for variables, functions, modules; `PascalCase` for types, traits, enums, variants).
- Use modules (`mod`) to organize code logically. Apply visibility modifiers (`pub`, `pub(crate)`, etc.) judiciously â€“ avoid making everything `pub`.
- Keep functions small and focused on a single responsibility.
