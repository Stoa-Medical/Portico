/// An Agent represents a component that listens for and reacts to Signals in the system.
///
/// The primary way to interact with an Agent is by assigning it a Mission (a Mission might be generated by a Signal)
///
/// Agents are responsible for:
/// - Monitoring specific Signal types or patterns
/// - Completing Missions by using configured Steps
///
/// NOTE: Agents are created in the UI, and Supabase is the source-of-truth for their state.
use crate::models::{
    runtime_sessions::RuntimeSession,
    steps::Step,
};
use crate::{IdFields, TimestampFields};

use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};

#[derive(sqlx::FromRow)]
pub struct Agent {
    #[sqlx(flatten)]
    identifiers: IdFields,
    #[sqlx(flatten)]
    timestamps: TimestampFields,
    description: String,
    agent_state: AgentState,
    accepted_completion_rate: f32,
    steps: Vec<Step>,
    completion_count: Arc<AtomicU64>,
    run_count: Arc<AtomicU64>,
}

/// Different states for Agent to be in. State diagram:
/// ```plain
///          (start)    ┌──────────┐
///  Inactive ───────► Stable ──┐  │
///      ▲              ▲       │  │
///      │              │ (err) │  │
///      │          Unstable ◄──┘  │
///      │   (stop)     │          │
///      └──────────────┘◄─────────┘
/// ```
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub enum AgentState {
    Inactive,
    Stable,
    Unstable,
}

impl Agent {
    pub fn new(
        identifiers: IdFields,
        timestamps: TimestampFields,
        description: String,
        accepted_completion_rate: f32,
        steps: Vec<Step>,
        completion_count: u64,
        run_count: u64
    ) -> Self {
        // Start all agents in an inactive state
        Self {
            identifiers,
            timestamps,
            description,
            agent_state: AgentState::Inactive,
            accepted_completion_rate,
            steps,
            completion_count: Arc::new(AtomicU64::new(completion_count)),
            run_count: Arc::new(AtomicU64::new(run_count))
        }
    }

    pub fn start(&mut self) -> Result<()> {
        match self.agent_state {
            AgentState::Inactive => {
                self.agent_state = self.update_stability();
                Ok(())
            }
            _ => Err(anyhow!("Can only start from Inactive state")),
        }
    }


    /// Process data with this agent
    pub async fn run(&mut self, source: Value) -> Result<RuntimeSession> {
        // Check if state is Inactive. If so, return error
        if self.agent_state == AgentState::Inactive {
            return Err(anyhow!("Cannot run agent in Inactive state"));
        }

        // Create a new RuntimeSession
        let mut session = RuntimeSession::new(source, self.steps.clone());

        // Start the RuntimeSession and handle the result
        let result = session.start().await;

        // If all steps completed successfully, increment completion count
        if result.is_ok() {
            self.completion_count.fetch_add(1, Ordering::Relaxed);
        }

        // Check stability and update state if needed
        self.update_stability();

        // If there was an error, propagate it
        if let Err(e) = result {
            return Err(e);
        }

        // Return final session
        Ok(session)
    }

    fn update_stability(&mut self) -> AgentState {
        match self.agent_state {
            AgentState::Inactive => AgentState::Inactive,
            _ => {
                let curr_completion_rate = self.collect_completion_rate();

                // Update state based on error rate
                if curr_completion_rate < self.accepted_completion_rate {
                    self.agent_state = AgentState::Unstable;
                    AgentState::Unstable
                } else {
                    self.agent_state = AgentState::Stable;
                    AgentState::Stable
                }
            }
        }
    }

    pub fn stop(&mut self) -> Result<()> {
        // Set to inactive
        match self.agent_state {
            AgentState::Stable | AgentState::Unstable => {
                self.agent_state = AgentState::Inactive;
                Ok(())
            },
            _ => Err(anyhow!("Can only stop from a running state")),
        }
    }

    fn collect_completion_rate(&self) -> f32 {
        // Calculate error rate based on this Agent's `run`s
        let collected_run_count = self.run_count.load(Ordering::Relaxed);
        let collected_completion_count = self.completion_count.load(Ordering::Relaxed);

        if collected_run_count == 0 {
            return 0.0; // No runs yet, so no errors
        }

        collected_completion_count as f32 / collected_run_count as f32
    }

}
