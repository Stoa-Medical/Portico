/// An Agent represents a component that listens for and reacts to Signals in the system.
///
/// The primary way to interact with an Agent is by assigning it a Mission (a Mission might be generated by a Signal)
///
/// Agents are responsible for:
/// - Monitoring specific Signal types or patterns
/// - Completing Missions by using configured Steps
///
/// NOTE: Agents are created in the UI, and Supabase is the source-of-truth for their state.
use crate::models::{
    runtime_sessions::RuntimeSession,
    steps::Step,
};
use crate::{IdFields, TimestampFields};

use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::sync::Arc;
use std::sync::atomic::{AtomicU64, Ordering};
use sqlx::{Postgres, Row};

#[derive(Debug)]
pub struct Agent {
    pub identifiers: IdFields,
    pub timestamps: TimestampFields,
    pub description: String,
    pub agent_state: AgentState,
    pub accepted_completion_rate: f32,
    pub steps: Vec<Step>,
    pub completion_count: Arc<AtomicU64>,
    pub run_count: Arc<AtomicU64>,
}

impl sqlx::FromRow<'_, sqlx::postgres::PgRow> for Agent {
    // Expect a SQL query like:
    // ```sql
    // SELECT
    // a.*,
    // COALESCE(
    //     (
    //         SELECT json_agg(json_build_object(
    //             'id', s.id,
    //             'global_uuid', s.global_uuid,
    //             'created_timestamp', s.created_timestamp,
    //             'last_updated_timestamp', s.last_updated_timestamp,
    //             'agent_id', s.agent_id,
    //             'name', s.name,
    //             'description', s.description,
    //             'step_type', s.step_type,
    //             'step_content', s.step_content,
    //             'success_count', s.success_count,
    //             'run_count', s.run_count
    //         ))
    //         FROM steps s
    //         WHERE s.agent_id = a.id
    //         ORDER BY s.sequence_number
    //     ),
    //     '[]'::json
    // ) as steps
    // FROM agents a
    fn from_row(row: &sqlx::postgres::PgRow) -> sqlx::Result<Self> {
        // Get the steps JSON array from the row
        let steps_json: Value = row.try_get("steps")?;

        // Convert the JSON array into Vec<Step> using the shared function
        let steps = Step::from_json_array(&steps_json);

        Ok(Self {
            identifiers: IdFields {
                local_id: row.try_get("id")?,
                global_uuid: row.try_get("global_uuid")?,
            },
            timestamps: TimestampFields {
                created: row.try_get("created_timestamp")?,
                updated: row.try_get("last_updated_timestamp")?,
            },
            description: row.try_get("description")?,
            agent_state: row.try_get("agent_state")?,
            accepted_completion_rate: row.try_get("accepted_completion_rate")?,
            steps,
            completion_count: Arc::new(AtomicU64::new(row.try_get::<i32, _>("completion_count")? as u64)),
            run_count: Arc::new(AtomicU64::new(row.try_get::<i32, _>("run_count")? as u64)),
        })
    }
}

/// Different states for Agent to be in. State diagram:
/// ```plain
///          (start)    ┌──────────┐
///  Inactive ───────► Stable ──┐  │
///      ▲              ▲       │  │
///      │              │ (err) │  │
///      │          Unstable ◄──┘  │
///      │   (stop)     │          │
///      └──────────────┘◄─────────┘
/// ```
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub enum AgentState {
    Inactive,
    Stable,
    Unstable,
}

impl sqlx::Type<Postgres> for AgentState {
    fn type_info() -> sqlx::postgres::PgTypeInfo {
        sqlx::postgres::PgTypeInfo::with_name("agent_state")
    }
}

impl<'r> sqlx::Decode<'r, Postgres> for AgentState {
    fn decode(value: sqlx::postgres::PgValueRef<'r>) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        match value.as_str()? {
            "inactive" => Ok(AgentState::Inactive),
            "stable" => Ok(AgentState::Stable),
            "unstable" => Ok(AgentState::Unstable),
            _ => Err("Invalid agent state".into()),
        }
    }
}

impl Agent {
    pub fn new(
        identifiers: IdFields,
        timestamps: TimestampFields,
        description: String,
        accepted_completion_rate: f32,
        steps: Vec<Step>,
        completion_count: u64,
        run_count: u64
    ) -> Self {
        // Start all agents in an inactive state
        Self {
            identifiers,
            timestamps,
            description,
            agent_state: AgentState::Inactive,
            accepted_completion_rate,
            steps,
            completion_count: Arc::new(AtomicU64::new(completion_count)),
            run_count: Arc::new(AtomicU64::new(run_count))
        }
    }

    pub fn start(&mut self) -> Result<()> {
        match self.agent_state {
            AgentState::Inactive => {
                self.agent_state = self.update_stability();
                Ok(())
            }
            _ => Err(anyhow!("Can only start from Inactive state")),
        }
    }


    /// Process data with this agent
    pub async fn run(&mut self, source: Value) -> Result<RuntimeSession> {
        // Check if state is Inactive. If so, return error
        if self.agent_state == AgentState::Inactive {
            return Err(anyhow!("Cannot run agent in Inactive state"));
        }

        // Create a new RuntimeSession
        let mut session = RuntimeSession::new(source, self.steps.clone());

        // Start the RuntimeSession and handle the result
        let result = session.start().await;

        // If all steps completed successfully, increment completion count
        if result.is_ok() {
            self.completion_count.fetch_add(1, Ordering::Relaxed);
        }

        // Check stability and update state if needed
        self.update_stability();

        // If there was an error, propagate it
        if let Err(e) = result {
            return Err(e);
        }

        // Return final session
        Ok(session)
    }

    fn update_stability(&mut self) -> AgentState {
        let curr_completion_rate = self.collect_completion_rate();

        // Update state based on error rate
        if curr_completion_rate < self.accepted_completion_rate {
            self.agent_state = AgentState::Unstable;
            AgentState::Unstable
        } else {
            self.agent_state = AgentState::Stable;
            AgentState::Stable
        }
    }

    pub fn stop(&mut self) -> Result<()> {
        // Set to inactive
        match self.agent_state {
            AgentState::Stable | AgentState::Unstable => {
                self.agent_state = AgentState::Inactive;
                Ok(())
            },
            _ => Err(anyhow!("Can only stop from a running state")),
        }
    }

    fn collect_completion_rate(&self) -> f32 {
        // Calculate error rate based on this Agent's `run`s
        let collected_run_count = self.run_count.load(Ordering::Relaxed);
        let collected_completion_count = self.completion_count.load(Ordering::Relaxed);

        if collected_run_count == 0 {
            return 0.0; // No runs yet, so no errors
        }

        collected_completion_count as f32 / collected_run_count as f32
    }

}
