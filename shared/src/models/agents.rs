/// An Agent represents a component that listens for and reacts to Signals in the system.
///
/// The primary way to interact with an Agent is by assigning it a Mission (a Mission might be generated by a Signal)
///
/// Agents are responsible for:
/// - Monitoring specific Signal types or patterns
/// - Completing Missions by using configured Steps
///
/// NOTE: Agents are created in the UI, and Supabase is the source-of-truth for their state.
use crate::models::{runtime_sessions::RuntimeSession, steps::Step};
use crate::{DatabaseItem, IdFields, JsonLike, TimestampFields};

use anyhow::{anyhow, Result};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use sqlx::{postgres::PgArgumentBuffer, PgPool, Postgres, Row};
use std::str::FromStr;
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::{Arc, Mutex};
use uuid::Uuid;

#[derive(Debug, Serialize, Deserialize)]
pub struct Agent {
    pub identifiers: IdFields,
    pub timestamps: TimestampFields,
    pub description: String,
    pub agent_state: Mutex<AgentState>,  // Make public for direct construction in other modules
    pub accepted_completion_rate: f64,
    pub steps: Vec<Step>,
    pub completion_count: Arc<AtomicU64>,
    pub run_count: Arc<AtomicU64>,
}

/// Different states for Agent to be in. State diagram:
/// ```plain
///          (start)    ┌──────────┐
///  Inactive ───────► Stable ──┐  │
///      ▲              ▲       │  │
///      │              │ (err) │  │
///      │          Unstable ◄──┘  │
///      │   (stop)     │          │
///      └──────────────┘◄─────────┘
/// ```
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize, Default)]
pub enum AgentState {
    #[default]
    Inactive,
    Stable,
    Unstable,
}

impl std::str::FromStr for AgentState {
    type Err = String;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "inactive" => Ok(AgentState::Inactive),
            "stable" => Ok(AgentState::Stable),
            "unstable" => Ok(AgentState::Unstable),
            _ => Err(format!("Invalid agent state: {}", s)),
        }
    }
}

impl AgentState {
    pub fn as_str(&self) -> &'static str {
        match self {
            AgentState::Inactive => "inactive",
            AgentState::Stable => "stable",
            AgentState::Unstable => "unstable",
        }
    }
}

impl sqlx::Type<Postgres> for AgentState {
    fn type_info() -> sqlx::postgres::PgTypeInfo {
        sqlx::postgres::PgTypeInfo::with_name("agent_state")
    }
}

impl<'r> sqlx::Decode<'r, Postgres> for AgentState {
    fn decode(
        value: sqlx::postgres::PgValueRef<'r>,
    ) -> Result<Self, Box<dyn std::error::Error + Send + Sync>> {
        match value.as_str()? {
            "inactive" => Ok(AgentState::Inactive),
            "stable" => Ok(AgentState::Stable),
            "unstable" => Ok(AgentState::Unstable),
            _ => Err("Invalid agent state".into()),
        }
    }
}

impl<'q> sqlx::Encode<'q, Postgres> for AgentState {
    fn encode_by_ref(
        &self,
        buf: &mut PgArgumentBuffer,
    ) -> Result<sqlx::encode::IsNull, Box<dyn std::error::Error + Send + Sync>> {
        let s = self.as_str();
        buf.extend_from_slice(s.as_bytes());
        Ok(sqlx::encode::IsNull::No)
    }
}

impl Agent {
    // Add getter and setter for agent_state
    pub fn state(&self) -> AgentState {
        let guard = self.agent_state.lock().unwrap();
        guard.clone()
    }

    pub fn set_state(&self, new_state: AgentState) {
        let mut guard = self.agent_state.lock().unwrap();
        *guard = new_state;
    }

    pub fn new(
        identifiers: IdFields,
        timestamps: TimestampFields,
        description: String,
        accepted_completion_rate: f64,
        steps: Vec<Step>,
        completion_count: u64,
        run_count: u64,
    ) -> Self {
        // Start all agents in an inactive state
        Self {
            identifiers,
            timestamps,
            description,
            agent_state: Mutex::new(AgentState::Inactive),
            accepted_completion_rate,
            steps,
            completion_count: Arc::new(AtomicU64::new(completion_count)),
            run_count: Arc::new(AtomicU64::new(run_count)),
        }
    }

    pub fn start(&self) -> Result<()> {
        let current_state = self.state();
        match current_state {
            AgentState::Inactive => {
                // Update stability and set new state
                let new_state = self.check_stability();
                self.set_state(new_state);
                Ok(())
            }
            _ => Err(anyhow!("Can only start from Inactive state")),
        }
    }

    /// Process data with this agent using an immutable reference
    pub async fn run(&self, source: Value) -> Result<RuntimeSession> {
        // Check if state is Inactive. If so, return error
        if self.state() == AgentState::Inactive {
            return Err(anyhow!("Cannot run agent in Inactive state"));
        }

        // Increment run count
        self.run_count.fetch_add(1, Ordering::Relaxed);

        // Create a new RuntimeSession
        let mut session = RuntimeSession::new(source, self.steps.clone());

        // Start the RuntimeSession and handle the result
        let result = session.start().await;

        // If all steps completed successfully, increment completion count
        if result.is_ok() {
            self.completion_count.fetch_add(1, Ordering::Relaxed);
        }

        // Check stability and update state if needed
        let new_state = self.check_stability();
        self.set_state(new_state);

        // If there was an error, propagate it
        if let Err(e) = result {
            return Err(e);
        }

        // Return final session
        Ok(session)
    }

    fn check_stability(&self) -> AgentState {
        let curr_completion_rate = self.collect_completion_rate();

        // Determine new state based on error rate
        if curr_completion_rate < self.accepted_completion_rate {
            AgentState::Unstable
        } else {
            AgentState::Stable
        }
    }

    pub fn stop(&self) -> Result<()> {
        // Set to inactive
        let current_state = self.state();
        match current_state {
            AgentState::Stable | AgentState::Unstable => {
                self.set_state(AgentState::Inactive);
                Ok(())
            }
            _ => Err(anyhow!("Can only stop from a running state")),
        }
    }

    fn collect_completion_rate(&self) -> f64 {
        // Calculate error rate based on this Agent's `run`s
        let collected_run_count = self.run_count.load(Ordering::Relaxed);
        let collected_completion_count = self.completion_count.load(Ordering::Relaxed);

        if collected_run_count == 0 {
            return 0.0; // No runs yet, so no errors
        }

        collected_completion_count as f64 / collected_run_count as f64
    }
}

impl sqlx::FromRow<'_, sqlx::postgres::PgRow> for Agent {
    // Expect a SQL query like:
    // ```sql
    // SELECT
    // a.*,
    // COALESCE(
    //     (
    //         SELECT json_agg(json_build_object(
    //             'id', s.id,
    //             'global_uuid', s.global_uuid,
    //             'created_at', s.created_at,
    //             'updated_at', s.updated_at,
    //             'agent_id', s.agent_id,
    //             'name', s.name,
    //             'description', s.description,
    //             'step_type', s.step_type,
    //             'step_content', s.step_content,
    //             'success_count', s.success_count,
    //             'run_count', s.run_count
    //         ))
    //         FROM steps s
    //         WHERE s.agent_id = a.id
    //         ORDER BY s.sequence_number
    //     ),
    //     '[]'::json
    // ) as steps
    // FROM agents a
    fn from_row(row: &sqlx::postgres::PgRow) -> sqlx::Result<Self> {
        // Get the steps JSON array from the row
        let steps_json: Value = row.try_get("steps")?;

        // Convert the JSON array into Vec<Step> using the shared function
        let steps = Step::from_json_array(&steps_json);

        // Get the agent state from the row
        let state: AgentState = row.try_get("agent_state")?;

        Ok(Self {
            identifiers: IdFields {
                local_id: row.try_get("id")?,
                global_uuid: row.try_get::<Uuid, _>("global_uuid")?.to_string(),
            },
            timestamps: TimestampFields {
                created: row.try_get("created_at")?,
                updated: row.try_get("updated_at")?,
            },
            description: row.try_get("description")?,
            agent_state: Mutex::new(state),
            accepted_completion_rate: row.try_get("accepted_completion_rate")?,
            steps,
            completion_count: Arc::new(AtomicU64::new(
                row.try_get::<i32, _>("completion_count")? as u64
            )),
            run_count: Arc::new(AtomicU64::new(
                row.try_get::<i32, _>("run_count")? as u64,
            )),
        })
    }
}

impl JsonLike for Agent {
    fn to_json(&self) -> Value {
        serde_json::json!({
            "id": self.identifiers.local_id,
            "global_uuid": self.identifiers.global_uuid,
            "created_at": self.timestamps.created.format("%Y-%m-%d %H:%M:%S").to_string(),
            "updated_at": self.timestamps.updated.format("%Y-%m-%d %H:%M:%S").to_string(),
            "description": self.description,
            "agent_state": self.state(),
            "accepted_completion_rate": self.accepted_completion_rate,
            "steps": self.steps.iter().map(|step| step.to_json()).collect::<Vec<Value>>(),
            "completion_count": self.completion_count.load(Ordering::Relaxed),
            "run_count": self.run_count.load(Ordering::Relaxed)
        })
    }

    fn from_json(obj: Value) -> Result<Self> {
        if let Some(obj) = obj.as_object() {
            Ok(Self {
                identifiers: IdFields {
                    local_id: obj.get("id").and_then(|v| v.as_i64()).map(|v| v as i32),
                    global_uuid: obj
                        .get("global_uuid")
                        .and_then(|v| v.as_str())
                        .unwrap_or_default()
                        .to_string(),
                },
                timestamps: TimestampFields {
                    created: chrono::DateTime::parse_from_str(
                        &obj.get("created_at")
                            .and_then(|v| v.as_str())
                            .unwrap_or_default(),
                        "%Y-%m-%d %H:%M:%S %z",
                    )
                    .unwrap_or_default()
                    .with_timezone(&chrono::Utc),
                    updated: chrono::DateTime::parse_from_str(
                        &obj.get("updated_at")
                            .and_then(|v| v.as_str())
                            .unwrap_or_default(),
                        "%Y-%m-%d %H:%M:%S %z",
                    )
                    .unwrap_or_default()
                    .with_timezone(&chrono::Utc),
                },
                description: obj
                    .get("description")
                    .and_then(|v| v.as_str())
                    .unwrap_or_default()
                    .to_string(),
                agent_state: Mutex::new(
                    obj.get("agent_state")
                        .and_then(|v| v.as_str())
                        .and_then(|s| AgentState::from_str(s).ok())
                        .unwrap_or_default()
                ),
                accepted_completion_rate: obj
                    .get("accepted_completion_rate")
                    .and_then(|v| v.as_f64())
                    .unwrap_or(0.0) as f64,
                steps: obj
                    .get("steps")
                    .and_then(|v| v.as_array())
                    .map(|arr| {
                        arr.iter()
                            .filter_map(|step| Step::from_json(step.clone()).ok())
                            .collect()
                    })
                    .unwrap_or_default(),
                completion_count: Arc::new(AtomicU64::new(
                    obj.get("completion_count")
                        .and_then(|v| v.as_i64())
                        .unwrap_or(0) as u64,
                )),
                run_count: Arc::new(AtomicU64::new(
                    obj.get("run_count").and_then(|v| v.as_i64()).unwrap_or(0) as u64,
                )),
            })
        } else {
            Err(anyhow!("Expected JSON object"))
        }
    }

    fn update_from_json(&mut self, obj: Value) -> Result<Vec<String>> {
        let mut updated_fields = Vec::new();

        if let Some(obj_map) = obj.as_object() {
            for (key, value) in obj_map {
                match key.as_str() {
                    "description" => {
                        if let Some(new_desc) = value.as_str() {
                            if self.description != new_desc {
                                self.description = new_desc.to_string();
                                updated_fields.push(key.to_string());
                            }
                        }
                    }
                    "agent_state" => {
                        if let Some(state_str) = value.as_str() {
                            match AgentState::from_str(state_str) {
                                Ok(new_state) => {
                                    let current_state = self.state();
                                    if current_state != new_state {
                                        self.set_state(new_state);
                                        updated_fields.push(key.to_string());
                                    }
                                }
                                Err(e) => {
                                    return Err(anyhow!(
                                        "Invalid agent state '{}': {}",
                                        state_str,
                                        e
                                    ))
                                }
                            }
                        }
                    }
                    "accepted_completion_rate" => {
                        if let Some(rate) = value.as_f64() {
                            let rate = rate as f64;
                            if (self.accepted_completion_rate - rate).abs() > f64::EPSILON {
                                self.accepted_completion_rate = rate;
                                updated_fields.push(key.to_string());
                            }
                        }
                    }
                    "steps" => {
                        if let Some(steps_array) = value.as_array() {
                            // This is more complex since we need to match existing steps
                            // For simplicity, we'll only update if the array is different in length
                            // A more complete solution would match steps by UUID and perform updates

                            let new_steps = steps_array
                                .iter()
                                .filter_map(|step_json| Step::from_json(step_json.clone()).ok())
                                .collect::<Vec<Step>>();

                            if self.steps.len() != new_steps.len() {
                                self.steps = new_steps;
                                updated_fields.push(key.to_string());
                            } else {
                                // Here, we could do more sophisticated comparison of steps
                                // For now, we'll just use a simple heuristic

                                // Count how many steps have matching UUIDs
                                let matching = self
                                    .steps
                                    .iter()
                                    .filter(|old_step| {
                                        new_steps.iter().any(|new_step| {
                                            old_step.identifiers.global_uuid
                                                == new_step.identifiers.global_uuid
                                        })
                                    })
                                    .count();

                                if matching != self.steps.len() {
                                    self.steps = new_steps;
                                    updated_fields.push(key.to_string());
                                }
                            }
                        }
                    }
                    "completion_count" => {
                        if let Some(count) = value.as_u64() {
                            let current = self.completion_count.load(Ordering::Relaxed);
                            if current != count {
                                self.completion_count.store(count, Ordering::Relaxed);
                                updated_fields.push(key.to_string());
                            }
                        }
                    }
                    "run_count" => {
                        if let Some(count) = value.as_u64() {
                            let current = self.run_count.load(Ordering::Relaxed);
                            if current != count {
                                self.run_count.store(count, Ordering::Relaxed);
                                updated_fields.push(key.to_string());
                            }
                        }
                    }
                    // Skip fields that shouldn't be updated directly
                    "id" | "global_uuid" | "created_at" | "updated_at" => {
                        // These fields are skipped intentionally
                    }
                    // Unknown fields
                    _ => {
                        // Optionally: log or warn about unknown fields
                    }
                }
            }

            // If any fields were updated, update the timestamp
            if !updated_fields.is_empty() {
                self.timestamps.update();
                updated_fields.push("updated_at".to_string());
            }

            Ok(updated_fields)
        } else {
            Err(anyhow!("Expected JSON object"))
        }
    }
}

#[async_trait]
impl DatabaseItem for Agent {
    fn id(&self) -> &IdFields {
        &self.identifiers
    }

    async fn try_db_create(&self, pool: &PgPool) -> Result<()> {
        // Check if an agent with the same UUID already exists
        if crate::check_exists_by_uuid(pool, "agents", &self.identifiers.global_uuid).await? {
            return Ok(());  // Agent already exists, no need to create it again
        }

        // First create the agent record
        let record = sqlx::query(
            r#"
            INSERT INTO agents (
                global_uuid, description, agent_state, accepted_completion_rate,
                completion_count, run_count, created_at, updated_at
            )
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            RETURNING id
            "#,
        )
        .bind(Uuid::parse_str(&self.identifiers.global_uuid)?)
        .bind(&self.description)
        .bind(&self.state())
        .bind(self.accepted_completion_rate)
        .bind(self.completion_count.load(Ordering::Relaxed) as i32)
        .bind(self.run_count.load(Ordering::Relaxed) as i32)
        .bind(&self.timestamps.created)
        .bind(&self.timestamps.updated)
        .fetch_one(pool)
        .await?;

        let agent_id: i64 = record.get("id");

        // Then create step records if any exist
        for (idx, step) in self.steps.iter().enumerate() {
            // Create a modified step with agent_id
            sqlx::query(
                r#"
                INSERT INTO steps (
                    global_uuid, agent_id, sequence_number, name, description,
                    step_type, step_content, success_count, run_count,
                    created_at, updated_at
                )
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
                "#,
            )
            .bind(&step.identifiers.global_uuid)
            .bind(agent_id)
            .bind(idx as i32)
            .bind(&step.name)
            .bind(&step.description)
            .bind(&step.step_type)
            .bind(&step.step_content)
            .bind(step.get_success_count() as i32)
            .bind(step.get_run_count() as i32)
            .bind(&step.timestamps.created)
            .bind(&step.timestamps.updated)
            .execute(pool)
            .await?;
        }

        Ok(())
    }

    async fn try_db_update(&self, pool: &PgPool) -> Result<()> {
        // Update the agent record
        sqlx::query(
            r#"
            UPDATE agents
            SET description = $1,
                agent_state = $2,
                accepted_completion_rate = $3,
                completion_count = $4,
                run_count = $5,
                updated_at = $6
            WHERE global_uuid = $7
            "#,
        )
        .bind(&self.description)
        .bind(&self.state())
        .bind(self.accepted_completion_rate)
        .bind(self.completion_count.load(Ordering::Relaxed) as i32)
        .bind(self.run_count.load(Ordering::Relaxed) as i32)
        .bind(&self.timestamps.updated)
        .bind(Uuid::parse_str(&self.identifiers.global_uuid)?)
        .execute(pool)
        .await?;

        // Steps should be updated through their own DatabaseItem implementation
        // since they have their own identifiers and lifecycle

        Ok(())
    }

    async fn try_db_delete(&self, pool: &PgPool) -> Result<()> {
        // First delete associated steps
        if let Some(id) = self.identifiers.local_id {
            sqlx::query("DELETE FROM steps WHERE agent_id = $1")
                .bind(id)
                .execute(pool)
                .await?;
        }

        // Then delete the agent
        sqlx::query("DELETE FROM agents WHERE global_uuid = $1")
            .bind(Uuid::parse_str(&self.identifiers.global_uuid)?)
            .execute(pool)
            .await?;

        Ok(())
    }

    async fn try_db_select_all(pool: &PgPool) -> Result<Vec<Self>> {
        let query = format!(
            r#"
            SELECT
                a.*,
                {}
            FROM agents a
            "#,
            crate::steps_json_agg_sql("a", "agent_id")
        );

        let rows = sqlx::query_as::<_, Self>(&query)
            .fetch_all(pool)
            .await?;

        Ok(rows)
    }

    async fn try_db_select_by_id(pool: &PgPool, id: &IdFields) -> Result<Option<Self>> {
        let result = if let Some(local_id) = id.local_id {
            let query = format!(
                r#"
                SELECT
                    a.*,
                    {}
                FROM agents a
                WHERE a.id = $1
                "#,
                crate::steps_json_agg_sql("a", "agent_id")
            );

            sqlx::query_as::<_, Self>(&query)
                .bind(local_id)
                .fetch_optional(pool)
                .await?
        } else {
            let query = format!(
                r#"
                SELECT
                    a.*,
                    {}
                FROM agents a
                WHERE a.global_uuid = $1
                "#,
                crate::steps_json_agg_sql("a", "agent_id")
            );

            sqlx::query_as::<_, Self>(&query)
                .bind(Uuid::parse_str(&id.global_uuid)?)
                .fetch_optional(pool)
                .await?
        };

        Ok(result)
    }
}
