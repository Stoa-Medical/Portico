use crate::models::runtime_sessions::RuntimeSession;
use crate::models::signals::Signal;
use crate::models::steps::Step;
/// An Agent represents a component that listens for and reacts to Signals in the system.
///
/// The primary way to interact with an Agent is by assigning it a Mission (a Mission might be generated by a Signal)
///
/// Agents are responsible for:
/// - Monitoring specific Signal types or patterns
/// - Completing Missions by using configured Steps
///
/// NOTE: Agents are created in the UI, and Supabase is the source-of-truth for their state.
use crate::{IdFields, TimestampFields};

use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use serde_json::Value;

pub struct Agent<'a> {
    // Database fields
    identifiers: IdFields,
    timestamps: TimestampFields,
    description: String,
    agent_state: AgentState,
    agent_type: AgentType,
    accepted_err_rate: f32,
    steps: Vec<Step<'a>>,
    // Runtime fields
    current_signal: Option<&'a Signal<'a>>,
    current_runtime_session: Option<&'a RuntimeSession<'a>>,
}

/// Different states for actor to be in. State diagram:
/// ```plain
///                    ┌────────────────┐
///                    │                │
///          (start)   v      (run)     |
///  Inactive ──────► Starting ──────► Stable ──┐
///      ▲             │   ▲            ▲       |
///      │             │   │ (check)    | (run) |
///      │             │   └───────► Unstable ◄─┘
///      |             v                |
///      └───────── Stopping ◄──────────┘
/// ```
#[derive(Debug, PartialEq, Clone, Serialize, Deserialize)]
pub enum AgentState {
    Inactive,
    Starting,
    Stable,
    Unstable,
    Stopping,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AgentType {
    /// Performs a specific action based on a CRON schedule
    Scheduled(String),
    /// Reacts to incoming data
    EventDriven,
}

impl<'a> Agent<'a> {
    pub fn new(
        identifiers: IdFields,
        timestamps: TimestampFields,
        description: String,
        accepted_err_rate: f32,
        steps: Vec<Step<'a>>,
        agent_type: AgentType,
    ) -> Self {
        // Start all agents in an inactive state
        Self {
            identifiers,
            timestamps,
            description,
            agent_state: AgentState::Inactive,
            agent_type,
            accepted_err_rate,
            steps,
            current_signal: None,
            current_runtime_session: None,
        }
    }

    /// Process data with this agent
    pub async fn process(&mut self, source: Value) -> Result<Value> {
        match self.agent_state {
            AgentState::Waiting | AgentState::Unstable => {
                // Set state to Running
                self.agent_state = AgentState::Running;

                // Convert Option<u64> to String
                let agent_id = self
                    .identifiers
                    .id
                    .map(|id| id.to_string())
                    .unwrap_or_else(|| "unknown".to_string());

                // Create a separate reference to steps to avoid borrowing self
                let steps = &self.steps;

                // Create runtime session
                let mut runtime_session =
                    RuntimeSession::new(IdFields::new(), agent_id, steps, source);

                // Run all steps and get the session result
                let session_result = runtime_session.run_all(true).await?;

                // Update agent state based on session result
                self.update_state_from_session(session_result.error_rate);

                // Return the result value or an error
                match session_result.result {
                    Some(val) => Ok(val),
                    None => match session_result.error {
                        Some(err) => Err(anyhow!(err)),
                        None => Ok(Value::Null),
                    },
                }
            }
            _ => Err(anyhow!(
                "Can only process data from Waiting or Unstable state"
            )),
        }
    }

    /// Update agent state based on session error rate
    fn update_state_from_session(&mut self, error_rate: f32) {
        self.agent_state = if error_rate <= self.accepted_err_rate {
            AgentState::Waiting
        } else {
            AgentState::Unstable
        };
    }

    pub fn start(&mut self) -> Result<()> {
        match self.agent_state {
            AgentState::Inactive => {
                self.agent_state = AgentState::Waiting;
                Ok(())
            }
            _ => Err(anyhow!("Can only start from Inactive state")),
        }
    }

    /// Returns Ok and sets to `Waiting` if stable, else Err and sets to `Unstable`
    pub fn check(&mut self) -> Result<()> {
        match self.agent_state {
            AgentState::Waiting | AgentState::Unstable => {
                let curr_err_rate = self.get_err_rate();
                let is_stable = curr_err_rate <= self.accepted_err_rate;

                // Update state based on stability
                self.agent_state = if is_stable {
                    AgentState::Waiting
                } else {
                    AgentState::Unstable
                };

                // Return result with appropriate message
                if is_stable {
                    Ok(())
                } else {
                    Err(anyhow!(
                        "Expected error rate <= {:.6}, got {:.6}",
                        self.accepted_err_rate,
                        curr_err_rate
                    ))
                }
            }
            _ => Err(anyhow!("Can only check from Waiting/Unstable state")),
        }
    }

    pub fn stop(&mut self) -> Result<()> {
        match self.agent_state {
            AgentState::Running | AgentState::Unstable | AgentState::Waiting => {
                self.agent_state = AgentState::Stopping;
                // Cleanup logic here if needed
                self.agent_state = AgentState::Inactive;
                Ok(())
            }
            _ => Err(anyhow!("Cannot stop from current state")),
        }
    }

    pub fn get_err_rate(&self) -> f32 {
        // Calculate error rate across all steps
        let total_runs: u64 = self.steps.iter().map(|step| step.get_run_count()).sum();

        if total_runs == 0 {
            return 0.0; // No runs yet, assume ok
        }

        let total_failures: u64 = self
            .steps
            .iter()
            .map(|step| step.get_run_count() - step.get_success_count())
            .sum();

        // Calculate error rate and return it
        total_failures as f32 / total_runs as f32
    }

    pub fn check_state(&self) -> &AgentState {
        &self.agent_state
    }

    // Getters and setters for database fields
    pub fn get_description(&self) -> &str {
        &self.description
    }

    pub fn set_description(&mut self, description: String) {
        self.description = description;
    }

    pub fn get_agent_type(&self) -> &AgentType {
        &self.agent_type
    }

    pub fn get_accepted_err_rate(&self) -> f32 {
        self.accepted_err_rate
    }

    pub fn set_accepted_err_rate(&mut self, rate: f32) {
        self.accepted_err_rate = rate;
    }

    // Signal-related methods (replacing Mission-related methods)
    pub fn assign_signal(&mut self, signal: &'a Signal<'a>) {
        self.current_signal = Some(signal);
    }

    pub fn get_current_signal(&self) -> Option<&'a Signal<'a>> {
        self.current_signal
    }

    pub fn clear_signal(&mut self) {
        self.current_signal = None;
    }

    /// Run the agent with provided data
    pub fn run(&self, _data: &serde_json::Value) -> Result<serde_json::Value, String> {
        // This method is called from Signal::process
        // Implementation would depend on your specific requirements
        // For now, returning a placeholder error
        Err("Agent run method not fully implemented".to_string())
    }
}
